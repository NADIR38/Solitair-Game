@page "/"
@using SolitaireGame.Backend
@using SolitaireGame.DataStructures
@implements IDisposable
@inject IJSRuntime JSRuntime
@inject ILocalStorageService LocalStorage
<PageTitle>Solitaire Game</PageTitle>

<div class="solitaire-container">
    <!-- Show Load Prompt on Startup -->
    @if (showLoadPrompt)
    {
        <div class="modal-overlay">
            <div class="modal-dialog">
                <h2>📂 Saved Game Found</h2>
                <p>You have a saved game from @savedGameDate</p>
                <p>Score: @savedGameScore | Moves: @savedGameMoves | Time: @savedGameTime</p>
                <div class="modal-buttons">
                    <button class="btn btn-primary" @onclick="LoadSavedGame">Load Game</button>
                    <button class="btn btn-secondary" @onclick="StartNewGame">New Game</button>
                </div>
            </div>
        </div>
    }

    <div class="game-header">
        <h1>🃏 Solitaire</h1>
        <div class="game-controls">
            <button class="btn btn-primary" @onclick="ConfirmNewGame">New Game</button>
            <button class="btn btn-secondary" @onclick="UndoMove" disabled="@(!canUndo)">↶ Undo</button>
            <button class="btn btn-secondary" @onclick="RedoMove" disabled="@(!canRedo)">↷ Redo</button>
            <button class="btn btn-success" @onclick="AutoComplete" disabled="@(!canAutoComplete)">Auto Complete</button>
        </div>
        <div class="game-stats">
            <span>Score: @(moveManager?.GetCurrentScore() ?? 0)</span>
            <span>Moves: @moveCount</span>
            <span>Time: @elapsedTime</span>
        </div>
    </div>

    @if (showWinMessage)
    {
        <div class="win-message">
            <h2>🎉 Congratulations! You Won! 🎉</h2>
            <p>Score: @(moveManager?.GetCurrentScore() ?? 0) | Moves: @moveCount | Time: @elapsedTime</p>
            <button class="btn btn-primary" @onclick="StartNewGame">Play Again</button>
        </div>
    }

    <!-- Rest of your game board HTML stays exactly the same -->
    <div class="game-board">
        <!-- Top Row: Stock, Waste, and Foundations -->
        <div class="top-row">
            <div class="left-section">
                <!-- Stock Pile -->
                <div class="stock-pile" @onclick="DrawCards">
                    @if (stockPile != null && stockPile.Count > 0)
                    {
                        <div class="card card-back">
                            <span class="card-count">@stockPile.Count</span>
                        </div>
                    }
                    else
                    {
                        <div class="card card-empty">
                            <span class="recycle-icon">↻</span>
                        </div>
                    }
                </div>

                <!-- Waste Pile -->
                <div class="waste-pile-container">
                    @if (wastePile != null)
                    {
                        var wasteCards = wastePile.GetAllCards();
                        if (wasteCards.Any())
                        {
                            var visibleCount = Math.Min(3, wasteCards.Count);
                            var startIndex = wasteCards.Count - visibleCount;

                            for (int i = 0; i < visibleCount; i++)
                            {
                                var card = wasteCards[startIndex + i];
                                var cardIndex = startIndex + i;
                                var offsetStyle = $"left: {i * 110}px; z-index: {i};";

                                <div class="card @GetCardColorClass(card)"
                                     style="@offsetStyle"
                                     draggable="true"
                                     @ondragstart="@((e) => OnDragStart(card, -1, cardIndex))"
                                     @ondragstart:preventDefault="false"
                                     @ondblclick="@(() => TryMoveWasteToFoundation(cardIndex))">
                                    <div class="card-content">
                                        <span class="card-rank">@GetRankDisplay(card.Rank)</span>
                                        <span class="card-suit">@GetSuitSymbol(card.Suit)</span>
                                    </div>
                                </div>
                            }
                        }
                        else
                        {
                            <div class="card card-empty"></div>
                        }
                    }
                </div>
            </div>

            <!-- Foundation Piles -->
            <div class="foundations">
                @if (foundationPile != null)
                {
                    @for (int i = 0; i < 4; i++)
                    {
                        var suit = (Suit)i;
                        var foundation = foundationPile.GetFoundation(suit);
                        var topCard = foundation.GetTopcard();
                        int foundationIndex = i;

                        <div class="foundation-pile"
                             @ondragover="@(e => OnDragOver(e))"
                             @ondragover:preventDefault="true"
                             @ondrop="@(() => OnDropOnFoundation(foundationIndex))">
                            @if (topCard != null)
                            {
                                <div class="card @GetCardColorClass(topCard)">
                                    <div class="card-content">
                                        <span class="card-rank">@GetRankDisplay(topCard.Rank)</span>
                                        <span class="card-suit">@GetSuitSymbol(topCard.Suit)</span>
                                    </div>
                                </div>
                            }
                            else
                            {
                                <div class="card card-foundation-empty">
                                    <span class="suit-placeholder">@GetSuitSymbol(suit)</span>
                                </div>
                            }
                        </div>
                    }
                }
            </div>
        </div>

        <!-- Tableau Piles -->
        <div class="tableau">
            @if (tableauPiles != null)
            {
                @for (int pileIdx = 0; pileIdx < 7; pileIdx++)
                {
                    var cards = tableauPiles.GetCardsInPile(pileIdx);
                    int currentPileIndex = pileIdx;

                    <div class="tableau-pile"
                         @ondragover="@(e => OnDragOver(e))"
                         @ondragover:preventDefault="true"
                         @ondrop="@(() => OnDropOnTableau(currentPileIndex))">
                        @if (cards.Any())
                        {
                            @for (int cardIdx = 0; cardIdx < cards.Count; cardIdx++)
                            {
                                var card = cards[cardIdx];
                                int currentCardIndex = cardIdx;
                                var topOffset = cardIdx * 30;
                                var zIndex = cardIdx + 1;

                                <div class="card @(card.IsFaceUp? GetCardColorClass(card) : "card-back")"
                                     style="position: absolute; top: @(topOffset)px; left: 0; z-index: @zIndex;"
                                     draggable="@card.IsFaceUp.ToString().ToLower()"
                                     @ondragstart="@((e) => OnDragStart(card, currentPileIndex, currentCardIndex))"
                                     @ondragstart:preventDefault="false"
                                     @ondblclick="@(() => TryMoveTableauToFoundation(currentPileIndex))">
                                    @if (card.IsFaceUp)
                                    {
                                        <div class="card-content">
                                            <span class="card-rank">@GetRankDisplay(card.Rank)</span>
                                            <span class="card-suit">@GetSuitSymbol(card.Suit)</span>
                                        </div>
                                    }
                                </div>
                            }
                        }
                        else
                        {
                            <div class="card card-empty"></div>
                        }
                    </div>
                }
            }
        </div>
    </div>
</div>

@code {
    // Game components
    private Deck deck;
    private TableauPiles tableauPiles;
    private FoundationPile foundationPile;
    private WastePile wastePile;
    private StockPile stockPile;
    private Movemanager moveManager;

    // Drag and drop state
    private Card draggedCard;
    private int dragSourcePile = -1;
    private int dragSourceCardIndex = -1;

    // Game state
    private int moveCount = 0;
    private bool showWinMessage = false;
    private bool canAutoComplete = false;
    private bool canUndo = false;
    private bool canRedo = false;

    // Timer
    private System.Threading.Timer gameTimer;
    private int elapsedSeconds = 0;
    private string elapsedTime = "00:00";

    // Load prompt state
    private bool showLoadPrompt = false;
    private string savedGameDate = "";
    private int savedGameScore = 0;
    private int savedGameMoves = 0;
    private string savedGameTime = "";
    private GameState pendingSavedState = null;

    // ✅ FIX: Use this flag to track initialization
    private bool isInitialized = false;
    private System.Threading.Timer autoSaveTimer;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            // ✅ Check for saved game in localStorage
            await CheckForSavedGameAsync();

            // Start auto-save timer
            StartAutoSaveTimer();

            Console.WriteLine($"✅ OnInitializedAsync completed. showLoadPrompt = {showLoadPrompt}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ Error in OnInitializedAsync: {ex.Message}");
        }
    }
    private void StartAutoSaveTimer()
    {
        autoSaveTimer?.Dispose();

        // Auto-save every 10 seconds
        autoSaveTimer = new System.Threading.Timer(_ =>
        {
            AutoSaveGame();
        }, null, 10000, 10000); // First save after 10s, then every 10s
    }


    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender && !isInitialized)
        {
            isInitialized = true;

            // Only start new game if no saved game found
            if (!showLoadPrompt)
            {
                Console.WriteLine("ℹ️ No saved game found, starting new game");
                NewGame();
                StateHasChanged();
            }
            else
            {
                Console.WriteLine("ℹ️ Saved game found, showing load prompt");
            }
        }
    }

    private async Task CheckForSavedGameAsync()
    {
        try
        {
            Console.WriteLine("🔍 Checking localStorage for saved game...");

            var tempTableau = new TableauPiles();
            var tempFoundation = new FoundationPile();
            var tempWaste = new WastePile();
            var tempStock = new StockPile(new List<Card>());
            var tempManager = new Movemanager(tempTableau, tempFoundation, tempWaste, tempStock);

            // ✅ Set localStorage service
            tempManager.SetLocalStorage(LocalStorage);

            var savedState = await tempManager.LoadGameAsync();

            if (savedState != null)
            {
                Console.WriteLine("✅ Saved game found in localStorage!");

                showLoadPrompt = true;
                pendingSavedState = savedState;
                savedGameDate = savedState.SavedAt.ToString("MMM dd, yyyy HH:mm");
                savedGameScore = savedState.CurrentScore;
                savedGameMoves = savedState.MoveCount;
                int seconds = savedState.ElapsedSeconds;
                savedGameTime = $"{seconds / 60:D2}:{seconds % 60:D2}";
            }
            else
            {
                Console.WriteLine("ℹ️ No saved game in localStorage");
                showLoadPrompt = false;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ Error checking localStorage: {ex.Message}");
            showLoadPrompt = false;
        }
    }
    private void LoadSavedGame()
    {
        try
        {
            Console.WriteLine("📂 Loading saved game from localStorage...");
            showLoadPrompt = false;

            if (pendingSavedState != null)
            {
                // ✅ Create initial empty components
                tableauPiles = new TableauPiles();
                foundationPile = new FoundationPile();
                wastePile = new WastePile();
                stockPile = new StockPile(new List<Card>());

                // ✅ Create moveManager with initial components
                moveManager = new Movemanager(tableauPiles, foundationPile, wastePile, stockPile);
                moveManager.SetLocalStorage(LocalStorage);

                // ✅ Restore the game state
                TableauPiles restoredTableau;
                FoundationPile restoredFoundations;
                WastePile restoredWaste;
                StockPile restoredStock;
                int restoredMoves, restoredSeconds, restoredScore;

                bool success = moveManager.RestoreGame(
                    pendingSavedState,
                    out restoredTableau,
                    out restoredFoundations,
                    out restoredWaste,
                    out restoredStock,
                    out restoredMoves,
                    out restoredSeconds,
                    out restoredScore
                );

                if (success)
                {
                    Console.WriteLine("✅ Game restored successfully!");

                    // ✅ CRITICAL: Update ALL references to the restored objects
                    tableauPiles = restoredTableau;
                    foundationPile = restoredFoundations;
                    wastePile = restoredWaste;
                    stockPile = restoredStock;  // ✅ This updates the UI reference

                    // ✅ IMPORTANT: Recreate moveManager with the restored components
                    moveManager = new Movemanager(tableauPiles, foundationPile, wastePile, stockPile);
                    moveManager.SetLocalStorage(LocalStorage);

                    moveCount = restoredMoves;
                    elapsedSeconds = restoredSeconds;
                    elapsedTime = $"{elapsedSeconds / 60:D2}:{elapsedSeconds % 60:D2}";
                    showWinMessage = false;

                    StartTimer();
                    UpdateUIState();

                    // ✅ Debug logging
                    Console.WriteLine($"Stock cards after load: {stockPile.Count}");
                    Console.WriteLine($"Waste cards after load: {wastePile.GetAllCards().Count}");
                }
                else
                {
                    Console.WriteLine("❌ Failed to restore game, starting new game");
                    NewGame();
                }
            }
            else
            {
                Console.WriteLine("⚠️ No pending saved state, starting new game");
                NewGame();
            }

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ Error loading saved game: {ex.Message}");
            Console.WriteLine($"   Stack: {ex.StackTrace}");
            NewGame();
            StateHasChanged();
        }
    }
 // ✅ UPDATE StartNewGame to delete from localStorage
    private async void StartNewGame()
    {
        Console.WriteLine("🆕 Starting new game");
        showLoadPrompt = false;

        // ✅ Delete saved game from localStorage
        await LocalStorage.RemoveItemAsync("solitaire_savegame");
        Console.WriteLine("🗑️ Deleted saved game from localStorage");

        NewGame();
        StateHasChanged();
    }
    private void ConfirmNewGame()
    {
        // Just start new game directly (or add confirmation if you want)
        Console.WriteLine("🆕 New game button clicked");
        NewGame();
    }

    private void StartTimer()
    {
        gameTimer?.Dispose();

        gameTimer = new System.Threading.Timer(_ =>
        {
            elapsedSeconds++;
            elapsedTime = $"{elapsedSeconds / 60:D2}:{elapsedSeconds % 60:D2}";
            InvokeAsync(StateHasChanged);
        }, null, 1000, 1000);
    }

    private void NewGame()
    {
        Console.WriteLine("🎮 Initializing new game...");
        gameTimer?.Dispose();

        deck = new Deck();
        deck.IntializeDeck();
        deck.ShuffleCards(deck.GetCards());

        tableauPiles = new TableauPiles();
        foundationPile = new FoundationPile();
        wastePile = new WastePile();

        tableauPiles.DealCards(deck);

        var remainingCards = new List<Card>();
        while (deck.GetrmainingCardCount() > 0)
        {
            remainingCards.Add(deck.DrawTopCard());
        }
        stockPile = new StockPile(remainingCards);

        moveManager = new Movemanager(tableauPiles, foundationPile, wastePile, stockPile);

        // ✅ Set localStorage service
        moveManager.SetLocalStorage(LocalStorage);

        moveManager.ResetScore();

        moveCount = 0;
        showWinMessage = false;
        elapsedSeconds = 0;
        elapsedTime = "00:00";

        UpdateUIState();
        StartTimer();
    }

    private void DrawCards()
    {
        if (moveManager != null && moveManager.DrawFromStock())
        {
            moveCount++;
            UpdateUIState();
            AutoSaveGame(); // ✅ Save after move
            StateHasChanged();
        }
    }

    private void OnDragStart(Card card, int pileIndex, int cardIndex)
    {
        draggedCard = card;
        dragSourcePile = pileIndex;
        dragSourceCardIndex = cardIndex;
    }

    private void OnDragOver(DragEventArgs e)
    {
        // Allow drop
    }

    private void OnDropOnTableau(int targetPileIndex)
    {
        if (draggedCard == null) return;

        bool success = false;

        if (dragSourcePile == -1)
        {
            success = moveManager.MoveWasteToTableau(targetPileIndex, dragSourceCardIndex);
        }
        else
        {
            success = moveManager.MoveTableauToTableau(dragSourcePile, dragSourceCardIndex, targetPileIndex);
        }

        if (success)
        {
            moveCount++;
            CheckWinCondition();
            AutoSaveGame(); // ✅ Save after move
        }

        ClearDragState();
        StateHasChanged();
    }

    private void OnDropOnFoundation(int foundationIndex)
    {
        if (draggedCard == null) return;

        bool success = false;

        if (dragSourcePile == -1)
        {
            success = moveManager.MoveWasteToFoundation(dragSourceCardIndex);
        }
        else
        {
            var cards = tableauPiles.GetCardsInPile(dragSourcePile);
            if (dragSourceCardIndex == cards.Count - 1)
            {
                success = moveManager.MoveTableauToFoundation(dragSourcePile);
            }
        }

        if (success)
        {
            moveCount++;
            CheckWinCondition();
            AutoSaveGame(); // ✅ Save after move
        }

        ClearDragState();
        StateHasChanged();
    }

    private void TryMoveWasteToFoundation(int wasteCardIndex)
    {
        var wasteCards = wastePile.GetAllCards();
        if (wasteCardIndex == wasteCards.Count - 1)
        {
            if (moveManager.MoveWasteToFoundation(wasteCardIndex))
            {
                moveCount++;
                CheckWinCondition();
                AutoSaveGame();
                StateHasChanged();
            }
        }
    }

    private void TryMoveTableauToFoundation(int pileIndex)
    {
        if (moveManager.MoveTableauToFoundation(pileIndex))
        {
            moveCount++;
            CheckWinCondition();
            AutoSaveGame();
            StateHasChanged();
        }
    }

    private void UndoMove()
    {
        if (moveManager != null && moveManager.UndoLastMove())
        {
            moveCount--;
            showWinMessage = false;
            UpdateUIState();
            StateHasChanged();
        }
    }

    private void RedoMove()
    {
        if (moveManager != null && moveManager.RedoLastMove())
        {
            moveCount++;
            CheckWinCondition();
            StateHasChanged();
        }
    }

    private void AutoComplete()
    {
        if (moveManager != null)
        {
            int movesMade = moveManager.AutoComplete();
            moveCount += movesMade;
            CheckWinCondition();
            StateHasChanged();
        }
    }

    private async void CheckWinCondition()
    {
        if (moveManager.CheckWin())
        {
            showWinMessage = true;
            gameTimer?.Dispose();

            // ✅ Delete saved game from localStorage
            await moveManager.DeleteSavedGameAsync();
        }

        UpdateUIState();
    }

    private void UpdateUIState()
    {
        if (moveManager != null)
        {
            canUndo = moveManager.CanUndo();
            canRedo = moveManager.CanRedo();
            canAutoComplete = moveManager.CanAutoComplete();
        }
    }

    private void ClearDragState()
    {
        draggedCard = null;
        dragSourcePile = -1;
        dragSourceCardIndex = -1;
    }

    private string GetCardColorClass(Card card)
    {
        return card.Color == Color.Red ? "card-red" : "card-black";
    }

    private string GetRankDisplay(Rank rank)
    {
        return rank switch
        {
            Rank.Ace => "A",
            Rank.Jack => "J",
            Rank.Queen => "Q",
            Rank.King => "K",
            _ => ((int)rank).ToString()
        };
    }

    private string GetSuitSymbol(Suit suit)
    {
        return suit switch
        {
            Suit.Hearts => "♥",
            Suit.Diamonds => "♦",
            Suit.Clubs => "♣",
            Suit.Spades => "♠",
            _ => ""
        };
    }
    private async void AutoSaveGame()
    {
        try
        {
            if (moveManager != null && !showWinMessage && moveCount > 0 && !showLoadPrompt)
            {
                Console.WriteLine($"💾 Auto-saving to localStorage... (Moves: {moveCount})");
                bool saved = await moveManager.SaveGameAsync(moveCount, elapsedSeconds);
                if (saved)
                {
                    Console.WriteLine("✅ Auto-save successful!");
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ Auto-save error: {ex.Message}");
        }
    }
    public async void Dispose()
    {
        gameTimer?.Dispose();
        autoSaveTimer?.Dispose();

        if (moveManager != null && !showWinMessage && moveCount > 0)
        {
            Console.WriteLine("💾 Final save on dispose...");
            await moveManager.SaveGameAsync(moveCount, elapsedSeconds);
        }
    }

}