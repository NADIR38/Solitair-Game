@page "/solitaire"
@using SolitaireGame.Backend
@using SolitaireGame.DataStructures
@implements IDisposable

<PageTitle>Solitaire Game</PageTitle>

<div class="solitaire-container">
    <div class="game-header">
        <h1>🃏 Solitaire</h1>
        <div class="game-controls">
            <button class="btn btn-primary" @onclick="NewGame">New Game</button>
            <button class="btn btn-secondary" @onclick="UndoMove" disabled="@(!canUndo)">↶ Undo</button>
            <button class="btn btn-secondary" @onclick="RedoMove" disabled="@(!canRedo)">↷ Redo</button>
            <button class="btn btn-success" @onclick="AutoComplete" disabled="@(!canAutoComplete)">Auto Complete</button>
        </div>
        <div class="game-stats">
            <span>Moves: @moveCount</span>
            <span>Time: @elapsedTime</span>
        </div>
    </div>

    @if (showWinMessage)
    {
        <div class="win-message">
            <h2>🎉 Congratulations! You Won! 🎉</h2>
            <p>Moves: @moveCount | Time: @elapsedTime</p>
            <button class="btn btn-primary" @onclick="NewGame">Play Again</button>
        </div>
    }

    <div class="game-board">
        <!-- Top Row: Stock, Waste, and Foundations -->
        <div class="top-row">
            <div class="left-section">
                <!-- Stock Pile -->
                <div class="stock-pile" @onclick="DrawCards">
                    @if (stockPile != null && stockPile.Count > 0)
                    {
                        <div class="card card-back">
                            <span class="card-count">@stockPile.Count</span>
                        </div>
                    }
                    else
                    {
                        <div class="card card-empty">
                            <span class="recycle-icon">↻</span>
                        </div>
                    }
                </div>

                <!-- Waste Pile -->
                <div class="waste-pile-container">
                    @if (wastePile != null)
                    {
                        var wasteCards = wastePile.GetAllCards();
                        if (wasteCards.Any())
                        {
                            // Show last 3 cards (or fewer if less available)
                            var visibleCount = Math.Min(3, wasteCards.Count);
                            var startIndex = wasteCards.Count - visibleCount;

                            for (int i = 0; i < visibleCount; i++)
                            {
                                var card = wasteCards[startIndex + i];
                                var cardIndex = startIndex + i;
                                var offsetStyle = $"left: {i * 110}px; z-index: {i};";

                                <div class="card @GetCardColorClass(card)"
                                     style="@offsetStyle"
                                     draggable="true"
                                     @ondragstart="@((e) => OnDragStart(card, -1, cardIndex))"
                                     @ondragstart:preventDefault="false"
                                     @ondblclick="@(() => TryMoveWasteToFoundation(cardIndex))">
                                    <div class="card-content">
                                        <span class="card-rank">@GetRankDisplay(card.Rank)</span>
                                        <span class="card-suit">@GetSuitSymbol(card.Suit)</span>
                                    </div>
                                </div>
                            }
                        }
                        else
                        {
                            <div class="card card-empty"></div>
                        }
                    }
                </div>
            </div>

            <!-- Foundation Piles -->
            <div class="foundations">
                @if (foundationPile != null)
                {
                    @for (int i = 0; i < 4; i++)
                    {
                        var suit = (Suit)i;
                        var foundation = foundationPile.GetFoundation(suit);
                        var topCard = foundation.GetTopcard();
                        int foundationIndex = i;

                        <div class="foundation-pile"
                             @ondragover="@(e => OnDragOver(e))"
                             @ondragover:preventDefault="true"
                             @ondrop="@(() => OnDropOnFoundation(foundationIndex))">
                            @if (topCard != null)
                            {
                                <div class="card @GetCardColorClass(topCard)">
                                    <div class="card-content">
                                        <span class="card-rank">@GetRankDisplay(topCard.Rank)</span>
                                        <span class="card-suit">@GetSuitSymbol(topCard.Suit)</span>
                                    </div>
                                </div>
                            }
                            else
                            {
                                <div class="card card-foundation-empty">
                                    <span class="suit-placeholder">@GetSuitSymbol(suit)</span>
                                </div>
                            }
                        </div>
                    }
                }
            </div>
        </div>

        <!-- Tableau Piles -->
        <div class="tableau">
            @if (tableauPiles != null)
            {
                @for (int pileIdx = 0; pileIdx < 7; pileIdx++)
                {
                    var cards = tableauPiles.GetCardsInPile(pileIdx);
                    int currentPileIndex = pileIdx;

                    <div class="tableau-pile"
                         @ondragover="@(e => OnDragOver(e))"
                         @ondragover:preventDefault="true"
                         @ondrop="@(() => OnDropOnTableau(currentPileIndex))">
                        @if (cards.Any())
                        {
                            @for (int cardIdx = 0; cardIdx < cards.Count; cardIdx++)
                            {
                                var card = cards[cardIdx];
                                int currentCardIndex = cardIdx;
                                var topOffset = cardIdx * 30;
                                var zIndex = cardIdx + 1;

                                <div class="card @(card.IsFaceUp? GetCardColorClass(card) : "card-back")"
                                     style="position: absolute; top: @(topOffset)px; left: 0; z-index: @zIndex;"
                                     draggable="@card.IsFaceUp.ToString().ToLower()"
                                     @ondragstart="@((e) => OnDragStart(card, currentPileIndex, currentCardIndex))"
                                     @ondragstart:preventDefault="false"
                                     @ondblclick="@(() => TryMoveTableauToFoundation(currentPileIndex))">
                                    @if (card.IsFaceUp)
                                    {
                                        <div class="card-content">
                                            <span class="card-rank">@GetRankDisplay(card.Rank)</span>
                                            <span class="card-suit">@GetSuitSymbol(card.Suit)</span>
                                        </div>
                                    }
                                </div>
                            }
                        }
                        else
                        {
                            <div class="card card-empty"></div>
                        }
                    </div>
                }
            }
        </div>
    </div>
</div>

@code {
    // Game components
    private Deck deck;
    private TableauPiles tableauPiles;
    private FoundationPile foundationPile;
    private WastePile wastePile;
    private StockPile stockPile;
    private Movemanager moveManager;

    // Drag and drop state
    private Card draggedCard;
    private int dragSourcePile = -1;
    private int dragSourceCardIndex = -1;

    // Game state
    private int moveCount = 0;
    private bool showWinMessage = false;
    private bool canAutoComplete = false;
    private bool canUndo = false;
    private bool canRedo = false;

    // Timer
    private System.Threading.Timer gameTimer;
    private int elapsedSeconds = 0;
    private string elapsedTime = "00:00";

    protected override void OnInitialized()
    {
        NewGame();
    }

    private void StartTimer()
    {
        gameTimer?.Dispose();

        gameTimer = new System.Threading.Timer(_ =>
        {
            elapsedSeconds++;
            elapsedTime = $"{elapsedSeconds / 60:D2}:{elapsedSeconds % 60:D2}";
            InvokeAsync(StateHasChanged);
        }, null, 1000, 1000);
    }

    private void NewGame()
    {
        gameTimer?.Dispose();

        deck = new Deck();
        deck.IntializeDeck();
        deck.ShuffleCards(deck.GetCards());

        tableauPiles = new TableauPiles();
        foundationPile = new FoundationPile();
        wastePile = new WastePile();

        tableauPiles.DealCards(deck);

        var remainingCards = new List<Card>();
        while (deck.GetrmainingCardCount() > 0)
        {
            remainingCards.Add(deck.DrawTopCard());
        }
        stockPile = new StockPile(remainingCards);

        moveManager = new Movemanager(tableauPiles, foundationPile, wastePile, stockPile);

        moveCount = 0;
        showWinMessage = false;
        elapsedSeconds = 0;
        elapsedTime = "00:00";

        UpdateUIState();
        StartTimer();
    }

    private void DrawCards()
    {
        if (moveManager != null && moveManager.DrawFromStock())
        {
            moveCount++;
            UpdateUIState();
            StateHasChanged();
        }
    }

    private void OnDragStart(Card card, int pileIndex, int cardIndex)
    {
        draggedCard = card;
        dragSourcePile = pileIndex;
        dragSourceCardIndex = cardIndex;
    }

    private void OnDragOver(DragEventArgs e)
    {
        // Allow drop by preventing default
    }

    private void OnDropOnTableau(int targetPileIndex)
    {
        if (draggedCard == null) return;

        bool success = false;

        if (dragSourcePile == -1) // From waste
        {
            success = moveManager.MoveWasteToTableau(targetPileIndex, dragSourceCardIndex);
        }
        else // From tableau
        {
            success = moveManager.MoveTableauToTableau(dragSourcePile, dragSourceCardIndex, targetPileIndex);
        }

        if (success)
        {
            moveCount++;
            CheckWinCondition();
        }

        ClearDragState();
        StateHasChanged();
    }

    private void OnDropOnFoundation(int foundationIndex)
    {
        if (draggedCard == null) return;

        bool success = false;

        if (dragSourcePile == -1) // From waste
        {
            success = moveManager.MoveWasteToFoundation(dragSourceCardIndex);
        }
        else // From tableau - only allow if dragging the top card
        {
            var cards = tableauPiles.GetCardsInPile(dragSourcePile);
            if (dragSourceCardIndex == cards.Count - 1) // Only top card
            {
                success = moveManager.MoveTableauToFoundation(dragSourcePile);
            }
        }

        if (success)
        {
            moveCount++;
            CheckWinCondition();
        }

        ClearDragState();
        StateHasChanged();
    }

    private void TryMoveWasteToFoundation(int wasteCardIndex)
    {
        // Only allow moving the top card (last card in waste)
        var wasteCards = wastePile.GetAllCards();
        if (wasteCardIndex == wasteCards.Count - 1)
        {
            if (moveManager.MoveWasteToFoundation(wasteCardIndex))
            {
                moveCount++;
                CheckWinCondition();
                StateHasChanged();
            }
        }
    }

    private void TryMoveTableauToFoundation(int pileIndex)
    {
        if (moveManager.MoveTableauToFoundation(pileIndex))
        {
            moveCount++;
            CheckWinCondition();
            StateHasChanged();
        }
    }

    private void UndoMove()
    {
        if (moveManager != null && moveManager.UndoLastMove())
        {
            moveCount--;
            showWinMessage = false;
            UpdateUIState();
            StateHasChanged();
        }
    }

    private void RedoMove()
    {
        if (moveManager != null && moveManager.RedoLastMove())
        {
            moveCount++;
            CheckWinCondition();
            StateHasChanged();
        }
    }

    private void AutoComplete()
    {
        if (moveManager != null)
        {
            int movesMade = moveManager.AutoComplete();
            moveCount += movesMade;
            CheckWinCondition();
            StateHasChanged();
        }
    }

    private void CheckWinCondition()
    {
        if (moveManager.CheckWin())
        {
            showWinMessage = true;
            gameTimer?.Dispose();
        }

        UpdateUIState();
    }

    private void UpdateUIState()
    {
        if (moveManager != null)
        {
            canUndo = moveManager.CanUndo();
            canRedo = moveManager.CanRedo();
            canAutoComplete = moveManager.CanAutoComplete();
        }
    }

    private void ClearDragState()
    {
        draggedCard = null;
        dragSourcePile = -1;
        dragSourceCardIndex = -1;
    }

    // Display helper methods
    private string GetCardColorClass(Card card)
    {
        return card.Color == Color.Red ? "card-red" : "card-black";
    }

    private string GetRankDisplay(Rank rank)
    {
        return rank switch
        {
            Rank.Ace => "A",
            Rank.Jack => "J",
            Rank.Queen => "Q",
            Rank.King => "K",
            _ => ((int)rank).ToString()
        };
    }

    private string GetSuitSymbol(Suit suit)
    {
        return suit switch
        {
            Suit.Hearts => "♥",
            Suit.Diamonds => "♦",
            Suit.Clubs => "♣",
            Suit.Spades => "♠",
            _ => ""
        };
    }

    public void Dispose()
    {
        gameTimer?.Dispose();
    }
}