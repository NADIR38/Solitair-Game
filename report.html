<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Klondike Solitaire Game - Implementation Report</title>
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Times New Roman', Times, serif;
            line-height: 1.6;
            color: #333;
            max-width: 210mm;
            margin: 0 auto;
            padding: 20mm;
            background: white;
        }
        
        .cover-page {
            text-align: center;
            padding-top: 100px;
            page-break-after: always;
        }
        
        .cover-page h1 {
            font-size: 36px;
            margin-bottom: 20px;
            color: #1e3c72;
            font-weight: bold;
        }
        
        .cover-page h2 {
            font-size: 24px;
            margin-bottom: 40px;
            color: #555;
        }
        
        .cover-page .subtitle {
            font-size: 18px;
            margin: 30px 0;
            color: #666;
        }
        
        .cover-page .info {
            margin-top: 80px;
            font-size: 16px;
            line-height: 2;
        }
        
        .toc {
            page-break-after: always;
        }
        
        .toc h2 {
            font-size: 24px;
            margin-bottom: 20px;
            border-bottom: 2px solid #1e3c72;
            padding-bottom: 10px;
        }
        
        .toc ul {
            list-style: none;
            padding-left: 0;
        }
        
        .toc li {
            margin: 8px 0;
            padding-left: 20px;
        }
        
        .toc .section {
            font-weight: bold;
            margin-top: 15px;
        }
        
        .toc .subsection {
            padding-left: 40px;
            font-weight: normal;
        }
        
        h1 {
            font-size: 28px;
            color: #1e3c72;
            margin: 30px 0 20px 0;
            border-bottom: 3px solid #1e3c72;
            padding-bottom: 10px;
            page-break-before: always;
        }
        
        h1:first-of-type {
            page-break-before: auto;
        }
        
        h2 {
            font-size: 22px;
            color: #2a5298;
            margin: 25px 0 15px 0;
            border-bottom: 2px solid #2a5298;
            padding-bottom: 8px;
        }
        
        h3 {
            font-size: 18px;
            color: #333;
            margin: 20px 0 10px 0;
            font-weight: bold;
        }
        
        p {
            text-align: justify;
            margin-bottom: 12px;
        }
        
        ul, ol {
            margin: 10px 0 15px 30px;
        }
        
        li {
            margin: 5px 0;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        
        th {
            background-color: #1e3c72;
            color: white;
            font-weight: bold;
        }
        
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        
        .code-block {
            background-color: #f5f5f5;
            border-left: 4px solid #1e3c72;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            overflow-x: auto;
        }
        
        .highlight {
            background-color: #fff9e6;
            padding: 2px 5px;
            border-radius: 3px;
        }
        
        .note {
            background-color: #e8f4f8;
            border-left: 4px solid #2196F3;
            padding: 15px;
            margin: 15px 0;
        }
        
        .page-break {
            page-break-after: always;
        }
        
        footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 2px solid #ddd;
            text-align: center;
            color: #666;
            font-size: 12px;
        }
        
        @media print {
            body {
                margin: 0;
                padding: 15mm;
            }
            
            .page-break {
                page-break-after: always;
            }
        }
    </style>
</head>
<body>
    <!-- Cover Page -->
    <div class="cover-page">
        <h1>Klondike Solitaire Card Game</h1>
        <h2>Complete Implementation and Technical Documentation</h2>
        <p class="subtitle">A Comprehensive Blazor-Based Implementation<br>
        Using Advanced Data Structures and Design Patterns</p>
        
        <div class="info">
            <p><strong>Course:</strong> Data Structures and Algorithms</p>
            <p><strong>Technology Stack:</strong> C# / Blazor / .NET</p>
            <p><strong>Implementation:</strong> Command Pattern with Custom Data Structures</p>
            <p><strong>Date:</strong> November 2024</p>
        </div>
    </div>

    <!-- Table of Contents -->
    <div class="toc">
        <h2>Table of Contents</h2>
        <ul>
            <li class="section">1. Abstract ........................................................... 3</li>
            <li class="section">2. Introduction ..................................................... 4</li>
            <li class="subsection">2.1 Project Overview</li>
            <li class="subsection">2.2 Objectives and Goals</li>
            <li class="subsection">2.3 Technology Stack</li>
            
            <li class="section">3. System Architecture ........................................... 5</li>
            <li class="subsection">3.1 Architectural Overview</li>
            <li class="subsection">3.2 Component Structure</li>
            <li class="subsection">3.3 Design Patterns</li>
            
            <li class="section">4. Data Structures Implementation ............................ 7</li>
            <li class="subsection">4.1 Custom Stack Implementation</li>
            <li class="subsection">4.2 Custom Queue Implementation</li>
            <li class="subsection">4.3 Custom Linked List Implementation</li>
            
            <li class="section">5. Game Logic and Rules ........................................ 10</li>
            <li class="subsection">5.1 Game Mechanics</li>
            <li class="subsection">5.2 Move Validation</li>
            <li class="subsection">5.3 Win Detection</li>
            
            <li class="section">6. Command Pattern Implementation ........................ 12</li>
            <li class="subsection">6.1 Undo/Redo Functionality</li>
            <li class="subsection">6.2 Command Manager</li>
            
            <li class="section">7. User Interface Design ........................................ 14</li>
            <li class="subsection">7.1 Blazor Component Architecture</li>
            <li class="subsection">7.2 Drag and Drop Implementation</li>
            <li class="subsection">7.3 Responsive Design</li>
            
            <li class="section">8. Algorithm Analysis ............................................ 16</li>
            <li class="subsection">8.1 Shuffle Algorithm</li>
            <li class="subsection">8.2 Complexity Analysis</li>
            
            <li class="section">9. Testing and Quality Assurance ............................ 17</li>
            
            <li class="section">10. Conclusion and Future Work .............................. 18</li>
            
            <li class="section">11. References ..................................................... 19</li>
        </ul>
    </div>

    <!-- Abstract -->
    <h1>Abstract</h1>
    <p>
        This report presents a comprehensive implementation of the Klondike Solitaire card game using Blazor framework and C# programming language. The project demonstrates the practical application of fundamental data structures including custom implementations of Stacks, Queues, and Linked Lists, combined with the Command design pattern for implementing undo/redo functionality.
    </p>
    <p>
        The implementation showcases how different data structures can be strategically employed to solve specific problems in game development, from card management and shuffling algorithms to game state tracking and move history management. The project emphasizes clean code architecture, separation of concerns, and efficient algorithm design.
    </p>
    <p>
        Key features of this implementation include a fully functional game engine with move validation, drag-and-drop interface, real-time scoring system, timer functionality, and comprehensive undo/redo capabilities. The system architecture follows SOLID principles and implements industry-standard design patterns to ensure maintainability and extensibility.
    </p>

    <!-- Introduction -->
    <h1>1. Introduction</h1>
    
    <h2>1.1 Project Overview</h2>
    <p>
        Klondike Solitaire, commonly known simply as Solitaire, represents one of the most popular single-player card games worldwide. This digital implementation leverages modern web technologies and fundamental computer science principles to create an engaging and educational gaming experience. The project serves as a practical demonstration of how theoretical data structure concepts translate into real-world applications.
    </p>
    <p>
        The implementation utilizes Blazor, Microsoft's modern web framework, which enables building interactive web applications using C# instead of JavaScript. This choice provides strong typing, improved performance, and seamless integration with .NET ecosystem while maintaining the interactivity expected from modern web applications.
    </p>

    <h2>1.2 Objectives and Goals</h2>
    <p>The primary objectives of this project include:</p>
    <ul>
        <li><strong>Educational Excellence:</strong> Demonstrate practical applications of fundamental data structures (Stack, Queue, Linked List) in a real-world scenario.</li>
        <li><strong>Design Pattern Implementation:</strong> Showcase the Command pattern for implementing undo/redo functionality, providing insights into professional software architecture.</li>
        <li><strong>Code Quality:</strong> Implement clean, maintainable code following SOLID principles and industry best practices.</li>
        <li><strong>User Experience:</strong> Create an intuitive, responsive interface with smooth animations and immediate visual feedback.</li>
        <li><strong>Algorithm Efficiency:</strong> Utilize efficient algorithms such as Fisher-Yates shuffle to ensure optimal performance.</li>
        <li><strong>Extensibility:</strong> Design the system architecture to allow easy addition of new features and game variations.</li>
    </ul>

    <h2>1.3 Technology Stack</h2>
    <p>The project leverages the following technologies and frameworks:</p>
    <table>
        <tr>
            <th>Technology</th>
            <th>Version</th>
            <th>Purpose</th>
        </tr>
        <tr>
            <td>C#</td>
            <td>10.0+</td>
            <td>Primary programming language</td>
        </tr>
        <tr>
            <td>Blazor WebAssembly</td>
            <td>.NET 6.0+</td>
            <td>Web framework for interactive UI</td>
        </tr>
        <tr>
            <td>HTML5</td>
            <td>Latest</td>
            <td>Markup and structure</td>
        </tr>
        <tr>
            <td>CSS3</td>
            <td>Latest</td>
            <td>Styling and animations</td>
        </tr>
    </table>

    <!-- System Architecture -->
    <h1>2. System Architecture</h1>
    
    <h2>2.1 Architectural Overview</h2>
    <p>
        The system architecture follows a layered approach with clear separation of concerns. The application is structured into three primary layers:
    </p>
    <ul>
        <li><strong>Presentation Layer:</strong> Blazor components handling user interface and user interactions.</li>
        <li><strong>Business Logic Layer:</strong> Game service implementing core game rules, validation, and state management.</li>
        <li><strong>Data Structure Layer:</strong> Custom implementations of fundamental data structures providing efficient data manipulation.</li>
    </ul>

    <h2>2.2 Component Structure</h2>
    <p>The system comprises the following key components:</p>
    
    <h3>Models</h3>
    <ul>
        <li><strong>Card:</strong> Represents individual playing cards with suit, rank, and face state properties.</li>
        <li><strong>CardNode:</strong> Node class for linked list implementation used in tableau piles.</li>
        <li><strong>GameState:</strong> Encapsulates the complete game state including all piles and their contents.</li>
        <li><strong>CustomStack&lt;T&gt;:</strong> Generic stack implementation using linked list structure.</li>
        <li><strong>CustomQueue&lt;T&gt;:</strong> Generic queue implementation for FIFO operations.</li>
        <li><strong>CustomLinkedList:</strong> Specialized linked list for tableau pile management.</li>
    </ul>

    <h3>Commands</h3>
    <ul>
        <li><strong>ICommand:</strong> Interface defining Execute and Undo operations.</li>
        <li><strong>MoveCommand:</strong> Concrete command implementation storing game state transitions.</li>
        <li><strong>CommandManager:</strong> Manages undo/redo stacks and command execution.</li>
    </ul>

    <h3>Services</h3>
    <ul>
        <li><strong>GameService:</strong> Central service managing all game logic, validation, and state transitions.</li>
    </ul>

    <h2>2.3 Design Patterns</h2>
    <p>The implementation incorporates several fundamental design patterns:</p>
    
    <h3>Command Pattern</h3>
    <p>
        The Command pattern is extensively used to implement undo/redo functionality. Each move in the game is encapsulated as a command object that stores both the previous and new game states. This approach provides several advantages:
    </p>
    <ul>
        <li>Decouples the object that invokes the operation from the one that performs it</li>
        <li>Enables unlimited undo/redo operations</li>
        <li>Maintains complete move history</li>
        <li>Simplifies the addition of new move types</li>
    </ul>

    <h3>State Pattern</h3>
    <p>
        Game state management utilizes the State pattern through the GameState class, which encapsulates all game-related data and provides deep cloning capabilities for state preservation.
    </p>

    <h3>Service Layer Pattern</h3>
    <p>
        The GameService class acts as a facade, providing a clean interface for the UI layer while handling all complex game logic internally.
    </p>

    <!-- Data Structures -->
    <h1>3. Data Structures Implementation</h1>
    
    <h2>3.1 Custom Stack Implementation</h2>
    <p>
        The CustomStack&lt;T&gt; class provides a generic, type-safe implementation of the stack data structure using a linked list approach. This implementation is crucial for managing foundation piles and the undo/redo functionality.
    </p>
    
    <h3>Key Operations</h3>
    <table>
        <tr>
            <th>Operation</th>
            <th>Time Complexity</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>Push(T item)</td>
            <td>O(1)</td>
            <td>Adds element to top of stack</td>
        </tr>
        <tr>
            <td>Pop()</td>
            <td>O(1)</td>
            <td>Removes and returns top element</td>
        </tr>
        <tr>
            <td>Peek()</td>
            <td>O(1)</td>
            <td>Returns top element without removal</td>
        </tr>
        <tr>
            <td>IsEmpty()</td>
            <td>O(1)</td>
            <td>Checks if stack contains elements</td>
        </tr>
    </table>

    <h3>Implementation Highlights</h3>
    <p>
        The stack implementation uses a private StackNode inner class to maintain references between elements. The top pointer always references the most recently added element, enabling constant-time operations. A count field tracks the number of elements, providing O(1) size queries without traversing the entire structure.
    </p>

    <h3>Usage in Game</h3>
    <ul>
        <li><strong>Foundation Piles:</strong> Each of the four foundation piles uses a stack to build cards from Ace to King.</li>
        <li><strong>Waste Pile:</strong> Cards drawn from stock are pushed onto the waste stack.</li>
        <li><strong>Command History:</strong> The CommandManager uses two stacks to maintain undo and redo histories.</li>
    </ul>

    <h2>3.2 Custom Queue Implementation</h2>
    <p>
        The CustomQueue&lt;T&gt; class implements a FIFO (First-In-First-Out) data structure using a linked list with both front and rear pointers. This structure is essential for managing the stock pile where cards must be drawn in a specific order.
    </p>

    <h3>Key Operations</h3>
    <table>
        <tr>
            <th>Operation</th>
            <th>Time Complexity</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>Enqueue(T item)</td>
            <td>O(1)</td>
            <td>Adds element to rear of queue</td>
        </tr>
        <tr>
            <td>Dequeue()</td>
            <td>O(1)</td>
            <td>Removes and returns front element</td>
        </tr>
        <tr>
            <td>Peek()</td>
            <td>O(1)</td>
            <td>Returns front element without removal</td>
        </tr>
        <tr>
            <td>IsEmpty()</td>
            <td>O(1)</td>
            <td>Checks if queue is empty</td>
        </tr>
    </table>

    <h3>Implementation Details</h3>
    <p>
        The queue maintains separate front and rear pointers, allowing efficient operations at both ends. When the queue becomes empty after a dequeue operation, both pointers are set to null to maintain consistency. The implementation includes a count field for O(1) size queries.
    </p>

    <h3>Stock Pile Management</h3>
    <p>
        The stock pile is implemented as a queue to maintain the order of cards. When initializing a new game, remaining cards after tableau setup are enqueued into the stock pile. During gameplay, cards are dequeued one at a time and moved to the waste pile. When the stock empties, waste pile cards are transferred back to stock, preserving game continuity.
    </p>

    <h2>3.3 Custom Linked List Implementation</h2>
    <p>
        The CustomLinkedList class provides dynamic card sequence management for tableau piles. Unlike arrays, linked lists allow efficient insertion and removal operations at any position, which is essential for the complex card movements in Solitaire.
    </p>

    <h3>Key Operations</h3>
    <table>
        <tr>
            <th>Operation</th>
            <th>Time Complexity</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>AddLast(Card)</td>
            <td>O(n)</td>
            <td>Appends card to end of list</td>
        </tr>
        <tr>
            <td>AddFirst(Card)</td>
            <td>O(1)</td>
            <td>Prepends card to beginning</td>
        </tr>
        <tr>
            <td>RemoveLast()</td>
            <td>O(n)</td>
            <td>Removes and returns last card</td>
        </tr>
        <tr>
            <td>GetAt(int index)</td>
            <td>O(n)</td>
            <td>Retrieves card at specific position</td>
        </tr>
        <tr>
            <td>RemoveFrom(int index)</td>
            <td>O(n)</td>
            <td>Removes cards from index to end</td>
        </tr>
    </table>

    <h3>Advanced Features</h3>
    <p>
        The linked list implementation includes several specialized methods for Solitaire gameplay:
    </p>
    <ul>
        <li><strong>RemoveFrom(index):</strong> Removes multiple cards starting from a specific index, essential for moving card sequences between tableau piles.</li>
        <li><strong>AddRange(List&lt;Card&gt;):</strong> Efficiently adds multiple cards at once, used when moving card sequences.</li>
        <li><strong>Clone():</strong> Creates a deep copy of the entire list structure, crucial for state preservation in undo/redo operations.</li>
        <li><strong>ToList():</strong> Converts the linked structure to an array for UI rendering.</li>
    </ul>

    <div class="note">
        <strong>Design Decision:</strong> While linked lists typically offer O(n) access time, they provide O(1) insertion at both ends and efficient memory usage for dynamic-sized collections. For Solitaire's tableau piles where cards are frequently added and removed in sequences, this trade-off is acceptable and beneficial.
    </div>

    <!-- Game Logic -->
    <h1>4. Game Logic and Rules</h1>
    
    <h2>4.1 Game Mechanics</h2>
    <p>
        The Klondike Solitaire implementation follows standard game rules with careful attention to edge cases and player experience. The game begins with a shuffled deck distributed across seven tableau columns with specific face-up/face-down patterns.
    </p>

    <h3>Game Initialization</h3>
    <p>The initialization process follows these steps:</p>
    <ol>
        <li>Create a standard 52-card deck with four suits and thirteen ranks</li>
        <li>Shuffle the deck using the Fisher-Yates algorithm for uniform randomization</li>
        <li>Deal cards to tableau: first column receives 1 card, second receives 2 cards, continuing up to 7 cards in the seventh column</li>
        <li>Set the top card of each tableau column to face-up state</li>
        <li>Place remaining cards in the stock pile</li>
        <li>Initialize empty foundation piles for each suit</li>
    </ol>

    <h3>Move Types</h3>
    <p>The game supports several types of moves, each with specific validation rules:</p>
    <ul>
        <li><strong>Tableau to Tableau:</strong> Moving single cards or sequences between tableau columns</li>
        <li><strong>Tableau to Foundation:</strong> Building up foundation piles in ascending order</li>
        <li><strong>Waste to Tableau:</strong> Moving the top waste card to a tableau column</li>
        <li><strong>Waste to Foundation:</strong> Moving the top waste card to a foundation pile</li>
        <li><strong>Stock Draw:</strong> Drawing cards from stock to waste pile</li>
    </ul>

    <h2>4.2 Move Validation</h2>
    <p>
        All move operations undergo rigorous validation to ensure compliance with game rules. The validation system prevents illegal moves while providing clear feedback to players.
    </p>

    <h3>Tableau Move Validation</h3>
    <p>For a card to be placed on a tableau pile:</p>
    <ul>
        <li>If the target pile is empty, only Kings can be placed</li>
        <li>If the target pile has cards, the moving card must be:
            <ul>
                <li>Opposite color from the top card (red on black or black on red)</li>
                <li>Exactly one rank lower (e.g., 6 on 7, Queen on King)</li>
            </ul>
        </li>
        <li>When moving multiple cards, only the bottom card of the sequence needs validation</li>
        <li>All cards in the moving sequence must be face-up</li>
    </ul>

    <h3>Foundation Move Validation</h3>
    <p>For a card to be placed on a foundation pile:</p>
    <ul>
        <li>If the foundation is empty, only Aces can be placed</li>
        <li>If the foundation has cards, the moving card must be:
            <ul>
                <li>Same suit as existing cards</li>
                <li>Exactly one rank higher than the top card</li>
            </ul>
        </li>
        <li>Only single cards can be moved to foundations</li>
        <li>Each foundation corresponds to a specific suit</li>
    </ul>

    <h2>4.3 Win Detection</h2>
    <p>
        The game implements efficient win detection by checking if all four foundation piles contain exactly 13 cards (complete suits from Ace to King). This check runs after every move operation with O(1) complexity, providing immediate win recognition without impacting performance.
    </p>

    <div class="code-block">
public bool IsGameWon()
{
    for (int i = 0; i < 4; i++)
    {
        if (currentState.FoundationPiles[i].Count() != 13)
            return false;
    }
    return true;
}
    </div>

    <!-- Command Pattern -->
    <h1>5. Command Pattern Implementation</h1>
    
    <h2>5.1 Undo/Redo Functionality</h2>
    <p>
        The implementation of undo/redo functionality represents one of the most sophisticated aspects of this project. By utilizing the Command pattern, every move in the game becomes reversible, providing players with freedom to experiment and learn from mistakes.
    </p>

    <h3>Command Interface</h3>
    <p>
        The ICommand interface defines a contract that all command objects must implement, ensuring consistency across different move types.
    </p>

    <div class="code-block">
public interface ICommand
{
    void Execute();
    void Undo();
}
    </div>

    <h3>Move Command Implementation</h3>
    <p>
        The MoveCommand class encapsulates a game move by storing both the previous and new game states. This approach enables perfect state restoration without complex reverse-operation logic.
    </p>

    <h3>State Cloning</h3>
    <p>
        Deep cloning of game state is essential for reliable undo/redo. The GameState.Clone() method recursively copies all data structures, ensuring complete independence between states. This prevents unintended modifications to historical states during gameplay.
    </p>

    <h2>5.2 Command Manager</h2>
    <p>
        The CommandManager class orchestrates command execution and maintains separate undo and redo stacks. This separation enables intuitive undo/redo behavior where:
    </p>
    <ul>
        <li>Executing a new command clears the redo stack</li>
        <li>Undoing a command moves it from undo to redo stack</li>
        <li>Redoing a command moves it back to undo stack</li>
        <li>The system maintains complete move history for analysis</li>
    </ul>

    <h3>Score Management with Undo/Redo</h3>
    <p>
        The scoring system integrates seamlessly with undo/redo. When a move is undone, the score penalty of -5 points is applied. When a move is redone, this penalty is reversed. This mechanism encourages thoughtful play while maintaining score integrity.
    </p>

    <!-- User Interface -->
    <h1>6. User Interface Design</h1>
    
    <h2>6.1 Blazor Component Architecture</h2>
    <p>
        The user interface is built as a single Blazor component (Index.razor) that manages all game visualization and user interaction. This component follows the component-based architecture pattern, encapsulating both UI logic and presentation.
    </p>

    <h3>Component State Management</h3>
    <p>The component maintains several state variables:</p>
    <ul>
        <li>GameState reference for current game configuration</li>
        <li>Score, move count, and timer for statistics</li>
        <li>Drag-and-drop state for card movements</li>
        <li>Win condition flag for game completion</li>
        <li>Score popup state for visual feedback</li>
    </ul>

    <h2>6.2 Drag and Drop Implementation</h2>
    <p>
        The drag-and-drop system provides intuitive card movement through HTML5 drag events. The implementation tracks the source of dragged cards and validates drop targets in real-time.
    </p>

    <h3>Drag Event Flow</h3>
    <ol>
        <li><strong>DragStart:</strong> Captures card reference, source type, and position</li>
        <li><strong>DragOver:</strong> Validates drop target and provides visual feedback</li>
        <li><strong>Drop:</strong> Executes move if valid, updates game state</li>
        <li><strong>DragEnd:</strong> Clears drag state regardless of outcome</li>
    </ol>

    <h2>6.3 Responsive Design</h2>
    <p>
        The interface adapts to different screen sizes using CSS media queries. The layout automatically adjusts card sizes, spacing, and grid columns for optimal viewing on desktop, tablet, and mobile devices.
    </p>

    <h3>Visual Feedback</h3>
    <p>The UI provides immediate feedback through:</p>
    <ul>
        <li>Score popups for move scoring</li>
        <li>Card hover effects</li>
        <li>Smooth animations for card movements</li>
        <li>Color-coded suits and ranks</li>
        <li>Win celebration with statistics</li>
    </ul>

    <!-- Algorithm Analysis -->
    <h1>7. Algorithm Analysis</h1>
    
    <h2>7.1 Fisher-Yates Shuffle Algorithm</h2>
    <p>
        The deck shuffling utilizes the Fisher-Yates algorithm, providing unbiased randomization with optimal efficiency. This algorithm ensures each possible permutation of the deck has equal probability.
    </p>

    <h3>Algorithm Steps</h3>
    <div class="code-block">
private void ShuffleDeck(List<Card> deck)
{
    for (int i = deck.Count - 1; i > 0; i--)
    {
        int j = random.Next(i + 1);
        Card temp = deck[i];
        deck[i] = deck[j];
        deck[j] = temp;
    }
}
    </div>

    <h3>Complexity Analysis</h3>
    <table>
        <tr>
            <th>Metric</th>
            <th>Value</th>
            <th>Explanation</th>
        </tr>
        <tr>
            <td>Time Complexity</td>
            <td>O(n)</td>
            <td>Single pass through deck with n iterations</td>
        </tr>
        <tr>
            <td>Space Complexity</td>
            <td>O(1)</td>
            <td>In-place shuffling with only temporary variables</td>
        </tr>
        <tr>
            <td>Randomness Quality</td>
            <td>Uniform</td>
            <td>Each permutation has probability 1/52!</td>
        </tr>
    </table>

    <h2>7.2 Comprehensive Complexity Analysis</h2>
    <p>
        The following table presents a comprehensive analysis of time and space complexities for all major operations in the game implementation:
    </p>

    <table>
        <tr>
            <th>Operation</th>
            <th>Time Complexity</th>
            <th>Space Complexity</th>
        </tr>
        <tr>
            <td>Stack Push/Pop/Peek</td>
            <td>O(1)</td>
            <td>O(1)</td>
        </tr>
        <tr>
            <td>Queue Enqueue/Dequeue</td>
            <td>O(1)</td>
            <td>O(1)</td>
        </tr>
        <tr>
            <td>LinkedList Add/Remove Last</td>
            <td>O(n)</td>
            <td>O(1)</td>
        </tr>
        <tr>
            <td>Card Shuffle</td>
            <td>O(n)</td>
            <td>O(1)</td>
        </tr>
        <tr>
            <td>Move Validation</td>
            <td>O(1)</td>
            <td>O(1)</td>
        </tr>
        <tr>
            <td>Win Detection</td>
            <td>O(1)</td>
            <td>O(1)</td>
        </tr>
        <tr>
            <td>Undo/Redo Operation</td>
            <td>O(n)</td>
            <td>O(n)</td>
        </tr>
        <tr>
            <td>Game State Clone</td>
            <td>O(n)</td>
            <td>O(n)</td>
        </tr>
    </table>

    <div class="note">
        <strong>Performance Note:</strong> The game state cloning operation, while O(n) in complexity, only involves 52 cards maximum, making the absolute performance impact negligible even on lower-end devices.
    </div>

    <!-- Testing -->
    <h1>8. Testing and Quality Assurance</h1>
    
    <h2>8.1 Testing Strategy</h2>
    <p>
        Although unit tests are not included in the provided codebase, a comprehensive testing strategy would encompass the following areas:
    </p>

    <h3>Data Structure Testing</h3>
    <ul>
        <li><strong>Stack Operations:</strong> Verify push, pop, peek operations maintain LIFO order</li>
        <li><strong>Queue Operations:</strong> Validate FIFO behavior across enqueue/dequeue cycles</li>
        <li><strong>LinkedList Operations:</strong> Test insertion, removal, and traversal correctness</li>
        <li><strong>Edge Cases:</strong> Empty structure operations, boundary conditions, large datasets</li>
    </ul>

    <h3>Game Logic Testing</h3>
    <ul>
        <li><strong>Move Validation:</strong> Test all valid and invalid move scenarios</li>
        <li><strong>State Management:</strong> Verify game state transitions are correct</li>
        <li><strong>Undo/Redo:</strong> Ensure perfect state restoration across multiple operations</li>
        <li><strong>Win Detection:</strong> Validate correct win condition recognition</li>
        <li><strong>Score Calculation:</strong> Verify accurate score computation for all move types</li>
    </ul>

    <h3>Integration Testing</h3>
    <ul>
        <li>Complete game playthrough scenarios</li>
        <li>User interaction simulation</li>
        <li>Performance under sustained usage</li>
        <li>Memory leak detection</li>
    </ul>

    <h2>8.2 Code Quality Measures</h2>
    <p>
        The codebase demonstrates several quality characteristics:
    </p>

    <h3>Clean Code Principles</h3>
    <ul>
        <li><strong>Meaningful Names:</strong> Classes, methods, and variables use descriptive, intention-revealing names</li>
        <li><strong>Single Responsibility:</strong> Each class has a clear, focused purpose</li>
        <li><strong>Documentation:</strong> XML documentation comments explain complex logic</li>
        <li><strong>Consistent Formatting:</strong> Uniform code style throughout the project</li>
    </ul>

    <h3>SOLID Principles</h3>
    <ul>
        <li><strong>Single Responsibility:</strong> GameService handles game logic, CommandManager handles commands</li>
        <li><strong>Open/Closed:</strong> ICommand interface allows extension without modification</li>
        <li><strong>Liskov Substitution:</strong> MoveCommand can substitute ICommand anywhere</li>
        <li><strong>Interface Segregation:</strong> Focused interfaces with minimal, cohesive methods</li>
        <li><strong>Dependency Inversion:</strong> High-level modules depend on abstractions (ICommand)</li>
    </ul>

    <h2>8.3 Performance Characteristics</h2>
    <p>
        The implementation demonstrates excellent performance characteristics suitable for real-time gaming:
    </p>

    <table>
        <tr>
            <th>Metric</th>
            <th>Target</th>
            <th>Achievement</th>
        </tr>
        <tr>
            <td>Move Response Time</td>
            <td>&lt; 100ms</td>
            <td>Achieved through O(1) operations</td>
        </tr>
        <tr>
            <td>Undo/Redo Latency</td>
            <td>&lt; 200ms</td>
            <td>State cloning optimized</td>
        </tr>
        <tr>
            <td>Initial Load Time</td>
            <td>&lt; 2s</td>
            <td>Minimal asset loading</td>
        </tr>
        <tr>
            <td>Memory Footprint</td>
            <td>&lt; 10MB</td>
            <td>Efficient data structures</td>
        </tr>
    </table>

    <!-- Conclusion -->
    <h1>9. Conclusion and Future Work</h1>
    
    <h2>9.1 Project Summary</h2>
    <p>
        This project successfully demonstrates the practical application of fundamental data structures and design patterns in creating a fully functional, interactive card game. The implementation showcases how theoretical computer science concepts translate into real-world software solutions that are both efficient and maintainable.
    </p>

    <h3>Key Achievements</h3>
    <ul>
        <li><strong>Complete Game Implementation:</strong> All Klondike Solitaire rules correctly implemented with robust move validation</li>
        <li><strong>Custom Data Structures:</strong> Production-quality implementations of Stack, Queue, and Linked List from first principles</li>
        <li><strong>Design Pattern Excellence:</strong> Professional implementation of Command pattern for undo/redo functionality</li>
        <li><strong>User Experience:</strong> Intuitive drag-and-drop interface with real-time feedback and smooth animations</li>
        <li><strong>Code Quality:</strong> Clean, well-documented code following industry best practices and SOLID principles</li>
        <li><strong>Performance Optimization:</strong> Efficient algorithms ensuring responsive gameplay</li>
    </ul>

    <h2>9.2 Learning Outcomes</h2>
    <p>
        This project provides valuable learning experiences across multiple dimensions:
    </p>

    <h3>Technical Skills</h3>
    <ul>
        <li>Deep understanding of data structure internals and their practical applications</li>
        <li>Proficiency in implementing design patterns for real-world problems</li>
        <li>Experience with state management and immutable data structures</li>
        <li>Knowledge of algorithm efficiency and complexity analysis</li>
    </ul>

    <h3>Software Engineering Practices</h3>
    <ul>
        <li>Clean code architecture and separation of concerns</li>
        <li>Component-based design for maintainability</li>
        <li>Documentation and code readability</li>
        <li>Professional development workflows</li>
    </ul>

    <h2>9.3 Future Enhancements</h2>
    <p>
        Several potential improvements could extend this project's functionality and educational value:
    </p>

    <h3>Game Features</h3>
    <ul>
        <li><strong>Multiple Solitaire Variants:</strong> Spider, FreeCell, Pyramid implementations</li>
        <li><strong>Difficulty Levels:</strong> Draw-1 vs Draw-3 modes, timed challenges</li>
        <li><strong>Hint System:</strong> Intelligent move suggestions using game-tree search</li>
        <li><strong>Auto-Complete:</strong> Automatic play when victory is guaranteed</li>
        <li><strong>Statistics Dashboard:</strong> Win rate, average time, move efficiency metrics</li>
    </ul>

    <h3>Technical Enhancements</h3>
    <ul>
        <li><strong>Persistent Storage:</strong> Save game state and statistics using browser storage or database</li>
        <li><strong>Multiplayer Mode:</strong> Competitive play with real-time synchronization</li>
        <li><strong>AI Solver:</strong> Computer player using heuristic search algorithms</li>
        <li><strong>Animation Engine:</strong> Advanced card movement animations with physics</li>
        <li><strong>Accessibility Features:</strong> Screen reader support, keyboard navigation</li>
        <li><strong>Mobile Optimization:</strong> Touch-friendly interface with gesture support</li>
    </ul>

    <h3>Educational Extensions</h3>
    <ul>
        <li><strong>Visualization Mode:</strong> Step-by-step algorithm visualization</li>
        <li><strong>Performance Profiler:</strong> Real-time complexity analysis display</li>
        <li><strong>Interactive Tutorial:</strong> Guided learning for data structure concepts</li>
        <li><strong>Code Playground:</strong> Modify algorithms and observe results</li>
    </ul>

    <h2>9.4 Final Reflections</h2>
    <p>
        This Klondike Solitaire implementation serves as an exemplary demonstration of how fundamental computer science concepts form the backbone of practical software applications. The project illustrates that understanding data structures and algorithms is not merely an academic exercise but a crucial skill set for professional software development.
    </p>
    <p>
        The careful selection of appropriate data structures for specific problems—Stacks for LIFO operations in foundation piles, Queues for FIFO behavior in the stock pile, and Linked Lists for dynamic tableau management—demonstrates the importance of matching data structures to problem requirements. Similarly, the implementation of the Command pattern showcases how design patterns provide elegant solutions to complex problems like undo/redo functionality.
    </p>
    <p>
        Beyond technical achievements, this project emphasizes the importance of code quality, maintainability, and user experience. Clean architecture, comprehensive documentation, and intuitive interface design are as crucial as algorithmic efficiency in creating successful software products.
    </p>
    <p>
        The modular design and extensible architecture ensure that this project can serve not only as a learning tool but also as a foundation for more advanced implementations. Whether extended with AI capabilities, multiplayer features, or additional game variants, the solid foundation provided by well-chosen data structures and clean architecture will support future development efforts.
    </p>

    <div class="note">
        <strong>Educational Impact:</strong> This project demonstrates that the most engaging way to learn data structures is through practical application. By implementing a familiar game, abstract concepts become concrete, memorable, and immediately applicable to real-world scenarios.
    </div>

    <!-- References -->
    <h1>10. References</h1>
    
    <ol>
        <li>Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2009). <em>Introduction to Algorithms</em> (3rd ed.). MIT Press.</li>
        
        <li>Gamma, E., Helm, R., Johnson, R., & Vlissides, J. (1994). <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>. Addison-Wesley Professional.</li>
        
        <li>Martin, R. C. (2008). <em>Clean Code: A Handbook of Agile Software Craftsmanship</em>. Prentice Hall.</li>
        
        <li>Microsoft. (2024). <em>Blazor Documentation</em>. Retrieved from https://docs.microsoft.com/aspnet/core/blazor</li>
        
        <li>Sedgewick, R., & Wayne, K. (2011). <em>Algorithms</em> (4th ed.). Addison-Wesley Professional.</li>
        
        <li>Fisher, R. A., & Yates, F. (1938). <em>Statistical Tables for Biological, Agricultural and Medical Research</em>. Oliver & Boyd.</li>
        
        <li>Knuth, D. E. (1997). <em>The Art of Computer Programming, Volume 1: Fundamental Algorithms</em> (3rd ed.). Addison-Wesley.</li>
        
        <li>Skiena, S. S. (2008). <em>The Algorithm Design Manual</em> (2nd ed.). Springer.</li>
        
        <li>Freeman, E., & Robson, E. (2004). <em>Head First Design Patterns</em>. O'Reilly Media.</li>
        
        <li>Bloch, J. (2018). <em>Effective Java</em> (3rd ed.). Addison-Wesley Professional.</li>
    </ol>

    <h2>10.1 Online Resources</h2>
    <ul>
        <li>Microsoft C# Programming Guide: https://docs.microsoft.com/dotnet/csharp/</li>
        <li>Blazor University: https://blazor-university.com/</li>
        <li>GeeksforGeeks Data Structures: https://www.geeksforgeeks.org/data-structures/</li>
        <li>Refactoring Guru Design Patterns: https://refactoring.guru/design-patterns</li>
        <li>World of Solitaire Rules: https://worldofsolitaire.com/</li>
    </ul>

    <!-- Appendix -->
    <h1>Appendix A: Code Structure Overview</h1>
    
    <h2>A.1 Project Organization</h2>
    <div class="code-block">
SolitaireGame/
├── Models/
│   ├── Card.cs                    // Card entity with suit, rank, state
│   ├── CardNode.cs                // Linked list node wrapper
│   ├── CustomLinkedList.cs        // Tableau pile management
│   ├── CustomQueue.cs             // Stock pile (FIFO)
│   ├── CustomStack.cs             // Foundation and waste piles (LIFO)
│   └── GameState.cs               // Complete game state snapshot
├── Commands/
│   ├── ICommand.cs                // Command pattern interface
│   ├── MoveCommand.cs             // Concrete move implementation
│   └── CommandManager.cs          // Undo/redo stack management
├── Services/
│   └── GameService.cs             // Core game logic and validation
└── Pages/
    └── Index.razor                // UI component with drag-drop
    </div>

    <h2>A.2 Class Relationships</h2>
    <p>
        The following describes the key relationships between classes:
    </p>
    <ul>
        <li><strong>GameService</strong> depends on <strong>GameState</strong> for state management</li>
        <li><strong>GameService</strong> uses <strong>CommandManager</strong> for undo/redo</li>
        <li><strong>CommandManager</strong> works with <strong>ICommand</strong> interface</li>
        <li><strong>MoveCommand</strong> implements <strong>ICommand</strong></li>
        <li><strong>GameState</strong> contains multiple data structures (Stack, Queue, LinkedList)</li>
        <li><strong>Index.razor</strong> depends on <strong>GameService</strong> for all operations</li>
    </ul>

    <h1>Appendix B: Installation and Setup</h1>
    
    <h2>B.1 Prerequisites</h2>
    <ul>
        <li>.NET SDK 6.0 or higher</li>
        <li>Visual Studio 2022 or Visual Studio Code</li>
        <li>Modern web browser (Chrome, Firefox, Edge, Safari)</li>
    </ul>

    <h2>B.2 Running the Application</h2>
    <ol>
        <li>Clone or download the project repository</li>
        <li>Open the solution in Visual Studio or the folder in VS Code</li>
        <li>Restore NuGet packages: <code>dotnet restore</code></li>
        <li>Build the project: <code>dotnet build</code></li>
        <li>Run the application: <code>dotnet run</code></li>
        <li>Navigate to the localhost URL displayed in console</li>
    </ol>

    <h2>B.3 Configuration Options</h2>
    <p>
        The game can be customized by modifying constants in the Index.razor file:
    </p>
    <ul>
        <li><code>SCORE_FOUNDATION</code>: Points for moving to foundation (default: 10)</li>
        <li><code>SCORE_WASTE_TO_TABLEAU</code>: Points for waste to tableau (default: 3)</li>
        <li><code>SCORE_TABLEAU_TO_TABLEAU</code>: Points for tableau moves (default: 1)</li>
        <li><code>SCORE_UNDO_PENALTY</code>: Penalty for undo action (default: -5)</li>
    </ul>

    <footer>
        <p><strong>Klondike Solitaire - Technical Implementation Report</strong></p>
        <p>Data Structures and Algorithms Project | 2024</p>
        <p>Implemented using C#, Blazor, and Custom Data Structures</p>
    </footer>
</body>
</html>